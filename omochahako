#!/usr/bin/env python3

import ctypes
import json
import os
import socket
import tarfile
import urllib.request
import uuid

libc = ctypes.CDLL('libc.so.6', use_errno=True)

sys_unshare = 272  # https://filippo.io/linux-syscall-table/


# pulled from linux/sched.h
CLONE_VM      = 0x00000100  # set if VM shared between processes
CLONE_FS      = 0x00000200  # set if fs info shared between processes
CLONE_FILES   = 0x00000400  # set if open files shared between processes
CLONE_SIGHAND = 0x00000800  # set if signal handlers and blocked signals shared
CLONE_PTRACE  = 0x00002000  # set if we want to let tracing continue on the child too
CLONE_VFORK   = 0x00004000  # set if the parent wants the child to wake it up on mm_release
CLONE_PARENT  = 0x00008000  # set if we want to have the same parent as the cloner
CLONE_THREAD  = 0x00010000  # Same thread group?
CLONE_NEWNS   = 0x00020000  # New mount namespace group
CLONE_SYSVSEM = 0x00040000  # share system V SEM_UNDO semantics
CLONE_SETTLS  = 0x00080000  # create a new TLS for the child
CLONE_PARENT_SETTID  = 0x00100000  # set the TID in the parent
CLONE_CHILD_CLEARTID = 0x00200000  # clear the TID in the child
CLONE_DETACHED       = 0x00400000  # Unused, ignored
CLONE_UNTRACED       = 0x00800000  # set if the tracing process can't force CLONE_PTRACE on this clone
CLONE_CHILD_SETTID   = 0x01000000  # set the TID in the child
CLONE_NEWCGROUP      = 0x02000000  # New cgroup namespace
CLONE_NEWUTS         = 0x04000000  # New utsname namespace
CLONE_NEWIPC         = 0x08000000  # New ipc namespace
CLONE_NEWUSER        = 0x10000000  # New user namespace
CLONE_NEWPID         = 0x20000000  # New pid namespace
CLONE_NEWNET         = 0x40000000  # New network namespace
CLONE_IO             = 0x80000000  # Clone io context


# pulled from linux/fs.h
MS_RDONLY      = 1     # Mount read-only
MS_NOSUID      = 2     # Ignore suid and sgid bits
MS_NODEV       = 4     # Disallow access to device special files
MS_NOEXEC      = 8     # Disallow program execution
MS_SYNCHRONOUS = 16    # Writes are synced at once
MS_REMOUNT     = 32    # Alter flags of a mounted FS
MS_MANDLOCK    = 64    # Allow mandatory locks on an FS
MS_DIRSYNC     = 128   # Directory modifications are synchronous
MS_NOATIME     = 1024  # Do not update access times.
MS_NODIRATIME  = 2048  # Do not update directory access times
MS_BIND        = 4096
MS_MOVE        = 8192
MS_REC         = 16384

MS_SILENT      = 32768
MS_POSIXACL    = (1<<16)  # VFS does not apply the umask
MS_UNBINDABLE  = (1<<17)  # change to unbindable
MS_PRIVATE     = (1<<18)  # change to private

omochahako_dir = os.path.join(os.path.expanduser('~'), '.omochahako')


def make_omochahako_dir():
    os.makedirs(os.path.join(omochahako_dir, 'layers'))


class DockerRegistry:
    def __init__(self):
        self.registry = 'https://registry-1.docker.io/v1'

    def pull(self, name, tag='latest'):
        token = self._get_token(name)
        id = self.get_id(name, token, tag=tag)
        layers = self.get_ancestry(id, token)

        rootdir = self.container_rootdir_name(name)
        os.makedirs(rootdir)
        print('building new root filesystem in', rootdir)

        for layer in reversed(layers):
            filename = self.layer_filename(layer)
            if not os.path.isfile(filename):
                # we've already downloaded this layer
                self.save_layer(layer, token)

            print('extracting', layer)
            self.untar_layer(layer, rootdir)

        return rootdir

    def layer_filename(self, id):
        return os.path.join(omochahako_dir, 'layers', id + '.tar')

    def container_rootdir_name(self, name):
        dir_name = '{}-{}'.format(name, uuid.uuid4())
        return os.path.join(omochahako_dir, 'containers', dir_name)

    def save_layer(self, id, token):
        filename = self.layer_filename(id)

        endpoint = '/images/{}/layer'.format(id)
        chunk_size = 16 * 1024
        with self._request_auth(self.registry + endpoint, token) as response:
            with open(filename, 'wb') as f:
                while True:
                    chunk = response.read(chunk_size)
                    if not chunk:
                        break
                    f.write(chunk)

    def untar_layer(self, id, rootdir):
        tar = tarfile.open(self.layer_filename(id), debug=0, errorlevel=0)
        tar.extractall(rootdir)

    def get_id(self, name, token, tag='latest'):
        r = self._get('/repositories/{}/tags/{}'.format(name, tag), token)
        return r.strip('"')

    def get_ancestry(self, id, token):
        return json.loads(self._get('/images/{}/ancestry'.format(id), token))

    def _get(self, endpoint, token):
        with self._request_auth(self.registry + endpoint, token) as f:
            return f.read().decode('utf-8')

    def _request_auth(self, url, token):
        req = urllib.request.Request(url)
        req.add_header('Authorization', 'Token {}'.format(token))
        return urllib.request.urlopen(req)

    def _get_token(self, name):
        url = ('https://index.docker.io'
               '/v1/repositories/{}/images'.format(name))
        req = urllib.request.Request(url)
        req.add_header('X-Docker-Token', 'true')
        with urllib.request.urlopen(req) as response:
            headers = dict(response.info())
            token = headers.get('X-Docker-Token')

        return token


def unshare(flags):
    '''
    Run the unshare syscall with some flags.

    If the return code is lower than 0, something went wrong.
    '''
    libc.syscall.argtypes = [ctypes.c_int, ctypes.c_int]
    r = libc.syscall(sys_unshare, flags)
    if r < 0:
        errno = ctypes.get_errno()
        raise RuntimeError("Error running unshare: {}".
         format(os.strerror(errno)))


def mount(source, target, fs, flags, options=0):
    r = libc.mount(source.encode('utf-8'),
                   target.encode('utf-8'),
                   fs.encode('utf-8') if fs else None,
                   flags,
                   options)
    if r < 0:
        errno = ctypes.get_errno()
        raise RuntimeError("Error mounting {} ({}) on {} with options '{}': {}".
         format(source, fs, target, options, os.strerror(errno)))


def map_user(id_inside_ns, id_outside_ns, length=1, pid=None):
    '''
    Write a mapping from a user inside the user namespace and one outside.
    '''
    if pid is None:
        pid = os.getpid()

    with open('/proc/{}/uid_map'.format(pid), 'w') as f:
        f.write('{} {} {}'.format(id_inside_ns, id_outside_ns, length))


def map_group(id_inside_ns, id_outside_ns, length=1, pid=None):
    if pid is None:
        pid = os.getpid()

    with open('/proc/{}/gid_map'.format(pid), 'w') as f:
        f.write('{} {} {}'.format(id_inside_ns, id_outside_ns, length))


def setgroups_write(pid=None):
    '''
    In linux 3.19, a change was made to the gid_map file. You now need to write
    'deny' to /proc/PID/setgroups in order to make changes in a namespace.
    '''
    if pid is None:
        pid = os.getpid()

    with open('/proc/{}/setgroups'.format(pid), 'w') as f:
        f.write('deny')


def set_mount_propagation():
    '''
    Set mount propagation to private recursively. Hopefully equivalent to

        mount --make-rprivate /

    This is needed to prevent mounts in this container leaking to the parent.
    '''
    mount('none', '/', None, MS_REC|MS_PRIVATE, None)


if __name__ == '__main__':
    if not os.path.isdir(omochahako_dir):
        make_omochahako_dir()

    registry = DockerRegistry()
    #registry.pull('ubuntu')

    user_id = os.geteuid()
    group_id = os.getegid()

    unshare(CLONE_NEWPID | CLONE_NEWNET |  CLONE_NEWNS |
            CLONE_NEWUTS | CLONE_NEWCGROUP | CLONE_NEWIPC |
            CLONE_NEWUSER)

    set_mount_propagation()

    setgroups_write()
    map_user(0, user_id)
    map_group(0, group_id)

    socket.sethostname('omochahako')  # add a new hostname

    # fork to enter the namespace
    pid = os.fork()

    if pid == 0:
        # mount a /proc filesystem in this namespace. Without this, tools like
        # ps and top will read from the global /proc and display the incorrect
        # information about processes
        mount('proc', '/proc', 'proc', MS_NOSUID|MS_NOEXEC|MS_NODEV)

        os.execl('/bin/sh', '/bin/sh')
    else:
        # this is the parent, just wait for the child to exit
        os.waitpid(pid, 0)
